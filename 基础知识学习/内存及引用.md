## 内存管理与引用
但是rust是一种基于C的高级语言，意味着它也继承了C语言的一些特点。在计算机语言不断演变过程中，出现了三种流派：  

* 垃圾回收机制(GC)，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
* 手动管理内存的分配和释放, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
* 通过所有权来管理内存，编译器在编译时会根据一系列规则进行检查

其中 Rust 选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失，内存是分为堆内存和栈内存。
* 栈的容量一般较小，在执行方法时会进行使用，栈的使用只能是按顺序的后进先出，无法使用中间的区域。栈上使用内存必须占用固定大小的内存。
* 堆内存使用时操作系统会从机器中申请一块足够大的空间，进行标记，通过一个指针来定位到对应的内存位置，因为指针的大小固定，所以是存储在栈中。使用时通过指针找到对应内存位置。  
从堆栈内存使用方式的区别可以看出，栈内存使用速度更快，对于Rust来说通过所有权控制内存按照以下规则：
> 1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
> 2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
> 3. 当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)

众所周知编写程序时方法之间的调用是一个很常见的情形，如果调用时将一个变量作为参数传递，传递的动作一样发生了变量所有权的转移
```
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
    // println!("s:{}",s)           // 此处代码如果去掉注释会编译报错，因为此时s的所有权因为方法的使用已经被销毁

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
```

为了应对方法传值后变量所有权同步消失的情况，只能将方法返回参数来保留所有权
```
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
```
这样的方式编写的代码很不优雅，因此在方法需要传递参数时需要使用引用来传递，可以在函数不返回参数值的情况下保留所有权

```
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(&s);             // s 引用的值移动到函数里 ...
    print!("s:{}",s);               // 方法正常执行
} 

fn takes_ownership(some_string: &String) { // 使用引用方式传递值，而不是将变量的值直接传入函数，可以在函数结束后仍保留所有权
    println!("{}", some_string);
} 
```